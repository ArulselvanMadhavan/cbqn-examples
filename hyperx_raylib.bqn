âŸ¨âŸ¨red, green, white, blackâŸ©â‡color, raylibâŸ©â†râ†â€¢Import "../rayed-bqn/rayed.bqn"
recâ†20
spacing â† 70
ctrlPtX â† 100
ctrlPtY â† 100
dims â† 7â€¿7
nd â† â‰ dims
nsize â† Ã—Â´dims
mat â† nsizeâ€¿nsize
dims_xy â† dims âˆ¾ 2

axisRots â† ((â†•â‰ dims)âŠ¸(âŒ½Ëœ))Â¨ â†•â‰ dims
revRots â† (((â†•nd)âŠ¸(âŒ½Ëœ))âˆ˜(Â¯1âŠ¸Ã—))Â¨ â†•nd

gridâ†spacing + (rec+spacing)Ã—>â¥Šâ†•dims
r.window.SetSize 0.5

InitMat â† {1âŒ¾(ğ•©âŠ¸âŠ‘) ğ•¨â¥Š0}

GenRot â† {ğ•¨ğ•Šğ•©:
    rots â† Â¯1â†“1+â†•â‰ ğ•©
    (ğ•¨âŠ¸(âŒ½Ëœ))Ë˜ rots
}

# Generate step table
vars â† (dimsâŠ¸InitMat)Â¨ â†•dims
GenStageRots â† {(GenRotËœâˆ˜(ğ•©âŠ¸(â‰Ëœ)))Â¨ axisRots}
# num_switches_m x stage_count_m x rots_per_stage_l x mat
rot_res â† >GenStageRotsÂ¨ â¥Švars
RevRot â† {(ğ•¨âŠ¸â‰)Ë˜ ğ•©}
hop_table â† {(revRots {ğ•¨ {RevRot}Â¨ ğ•©}Ë˜ ğ•©)}Ë˜ rot_res
data â† (10âŠ¸+)âˆ˜>âˆ˜(dimsâŠ¸â¥ŠÂ¨) â†•nsize
out_t â† +Ë data

Flip â† {
    HasFlag â† ((0âŠ¸<)âˆ˜+Â´âˆ˜â¥Š)
    MaybeFlip â† HasFlagâ—¶âŸ¨âŠ¢,Â¬âŸ©
    IsFlippable â† (0âŠ¸<)âˆ˜(â‰ â‰¢)
    Fn â† IsFlippableâ—¶âŸ¨âŠ¢,MaybeFlipâŸ©
    Fn ğ•©
}

pkt_flags â† {(Flipâ‰(ğ•©))Â¨ vars}Â¨ (âŒ½â†•nd)
dd â† >â‹ˆâ‰Â¯1 data
hop_reduce â† â‰hop_table

HopRdc â† {ğ•¨ğ•Šhop_id:
hop_d â† hop_id âŠ hop_reduce
pkt_d â† â¥Šâˆ˜>(hop_id âŠ pkt_flags)
data â† >ğ•¨
ldata â† (Â¯1âŠ¸âŠ)Ë˜ ğ•¨
SwRdc â† {sw_idğ•Šğ•©:
    sw_d â† (sw_id âŠ ldata)
    pkt_f â† âŠ‘(sw_id âŠ pkt_d)
    sw_f â† âŠ‘(sw_id âŠ â¥Švars)
    StepRdc â† {
        pkt_f â† (sw_f â‰¡ pkt_f)âŠ‘(pkt_fâ€¿(pkt_fâ‰ pkt_f))
        hop_d â† âŠ‘(â¥Šğ•©) / (<Ë˜ ldata)
        pkt_d â† Ã—âŸœhop_dÂ¨ sw_fâ€¿pkt_f
        +Â´ (â‹ˆğ•¨)âˆ¾pkt_d
    }
    outstep â† (<Ë˜ sw_d) StepRdc` (â‹ˆË˜ ğ•©)
    âˆ¾Ë˜outstep
 }
 (â†•(â‰¢hop_d)) SwRdcË˜ (>hop_d)
}

out_s â† (â‹ˆ dd) HopRdc` (â‹ˆË˜ (â†•(â‰ hop_reduce)))

AddCtrlPts â†{dim_idğ•Š[x1â€¿y1â‹„x2â€¿y2]:
  ctrlOffsets â† [[(5Ã·ctrlPtX)â€¿0, (Â¯1Ã—ctrlPtX)â€¿0], [(0â€¿(5 Ã· ctrlPtY)), (0â€¿(Â¯1Ã—ctrlPtY))]]
  ctrlOffset â† dim_idâŠctrlOffsets
  plus â† 0âŠctrlOffset
  sub â† 1âŠctrlOffset
  res â† (âˆ¾âŸœ((+âŸœplus)â‰(subâŠ¸+)))Ë˜ ğ•©
  # Convert mxnxk - (mxn)xk and then convert rank 2 array to list of lists
  <â¥Šâˆ˜(â‹ˆâ‰(Â¯1))âˆ˜âˆ¾â‹ˆâ‰Â¯1 res
}

DrawBezier â† {râ€¿gâ€¿bâ€¿ağ•Špts:
    args â† ptsâˆ¾4âˆ¾2.0â‹ˆğ•¨
    raylib.DrawSplineBezierCubic args
}â‰1â€¿2

GenOff â† {ğ•Šğ•©:
      midtp â† ğ•©
      lastDim â† 1â†“â†•(Â¯2âŠ¸âŠ‘â‰¢) midtp
      rotations â† {(ğ•©âŠ¸âŒ½)â‰2 midtp}Â¨ lastDim
      {midtp â‰â‰1 ğ•©}Â¨ rotations
  }

PerFrame â† {ğ•¤
    pos â† r.mouse.GetPos@
    ellipseGrid â† {â‰âŸœ(+âŸœrec)}Ë˜ grid
    {white r.draw.EllipseOutline ğ•©}Ë˜ ellipseGrid
    midpts â† Ã·âŸœ2âˆ˜+Ëâ‰2 ellipseGrid
    midpts_xy â† dims_xy â¥Š midpts
    offsets â† (GenOffâˆ˜(midptsxyâŠ¸(â‰Ëœ)))Â¨ axisRots
    # offsets - dims x rots_per_dim x dim_1 x dim_n x 2
    flags â† (âŒ½âˆ˜â†•nd) {(ğ•¨âŠ¸âŠ‘âˆ˜<Ëâ‰2)Â¨ğ•©}Â¨ offsets
    # flags - dims x rots_per_dim x dim_1 x dim_2
    curves â† flags (/Ë˜)Â¨Â¨ offsets
    curvePts â† (â†•nd) {ğ•¨âŠ¸AddCtrlPtsË˜Ë˜Â¨ ğ•©}Â¨ curves
    {red DrawBezier ğ•©}Ë˜Ë˜Â¨Â¨ curvePts

} r.draw._withCanvasâŸœblack

PerFrameâ€¢_While_(Â¬r.window.ShouldClose)r.window._openAs "HyperX"
